\documentclass[a4paper,11pt]{ltjsreport}

% ===== パッケージ =====
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{subcaption}
\usepackage{placeins}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny,
  captionpos=b,
  tabsize=2
}



\onehalfspacing   

% ===== 表紙情報 =====

\geometry{
  top=30mm,
  bottom=30mm,
  left=30mm,
  right=30mm
}

\begin{document}

\thispagestyle{empty}

\vspace*{25mm}

\begin{center}

{\fontsize{20pt}{18pt}\selectfont コンピュータ科学科情報システム系卒業論文}

\vspace{35mm}

{\fontsize{24pt}{24pt}\selectfont\bfseries
DTVMを用いたオフチェーン型\\スマートコントラクト実行基盤の\\組込みシステムへの適用
}

\vfill

{\fontsize{20pt}{18pt}\selectfont 2026 年 2 月}

\vspace{12mm}

{\fontsize{20pt}{18pt}\selectfont
102230045 \quad 岩見\ 一輝
}

\end{center}

\newpage


\section*{概要}
\addcontentsline{toc}{chapter}{概要}

近年，IoT技術の普及に伴い，組込み機器間での自律的な取引やデータ管理を実現する手段としてブロックチェーンおよびスマートコントラクトの活用が期待されている\cite{iot-blockchain}。
しかし，すべてをノード上で実行する従来のフルオンチェーン実行方式では，膨大な計算コストや実行遅延，およびガスコストの発生が課題となり，計算資源や電力に制約のある組込み機器への適用は困難であった。
また現在のブロックチェーンはクラウドサーバ等の外部リソースに依存した構成が一般的であるが，これは通信遅延や単一障害点のリスクを増大させる要因となっている。

本研究では，組込み機器上でもスマートコントラクトを実行可能とするために，計算処理をデバイス近傍のオフチェーン環境で実行し，
その実行結果のみをブロックチェーンに記録するオフチェーン実行＋オンチェーン同期型の手法を提案する。
オフチェーン実行基盤として，決定論的実行を保証し，高速な実行性能を有する WebAssembly ベースの仮想マシンである DTVM を採用する。
DTVM はブロックチェーンへの接続機能を持たないため，本研究では DTVM の実行結果を取得し，ブロックチェーン上のスマートコントラクトへ送信・保存する接続機構を構築した。

提案手法の有効性を評価するため，一般的な PC 環境上において，フィボナッチ数列計算を対象とした評価実験を行った。
EVM によるフルオンチェーン実行方式と，DTVM を用いたオフチェーン実行方式について，実行時間，メモリ使用量，およびガスコストの観点から比較を行った。
その結果，オフチェーン実行方式では実行時間およびメモリ使用量がわずかに増加した一方，ガスコストは約 50\%削減されることを確認した。

本研究の提案手法はガスコスト削減の観点において有効であり，リソース制約環境におけるスマートコントラクト実行の一手法として有用であることを示した。
しかし実行時間とメモリ使用量については本研究の提案手法が従来の方式と比較してわずかに増加した。
これは従来の方式が計算処理と結果の保存を1つのトランザクションで実行していることに対して，提案手法ではDTVMを呼び出した後に保存用コントラクトを呼ぶという二回の手順を踏んでいる
ことによるオーバーヘッドが大きいためであると考えられる。そのためDTVMを呼び出した後そのまま直接ブロックチェーンに送信するようなオーバーヘッドを削減する新たな接続機構を作成する必要がある。
今後の課題として，本実験ではPC上で比較検証したが，実際にRaspberry PiやIoT機器等で同様の実験を行い，本実験での結果との差異がどの程度あるのかも検証する必要がある。
またオフチェーン実行によるデメリットであるセキュリティ性の低下と，状態保存がされないことから結果を再利用することができないという二つの点も解決する必要がある。

\newpage

% ===== 目次 =====
\tableofcontents
\clearpage

\listoffigures
\clearpage

\listoftables
\clearpage


% ===== 本文開始 =====
\chapter{はじめに}
\section{研究背景}
近年，IoT技術の急速な普及により，センサーデバイスやアクチュエータなどの組込み機器がネットワークを介して相互に接続される社会が実現しつつある。
IoT技術は，スマートシティ，自動運転，サプライチェーン管理，産業用ロボットなど，多岐にわたる分野で基盤技術として活用されている。
これらのシステムでは，膨大な数のデバイス間でデータの授受や価値の取引が自律的に行われることが期待されており，その信頼性を担保する技術としてブロックチェーンおよびスマートコントラクトが注目を集めている\cite{iot-blockchain,security,bcot}。
スマートコントラクトは，あらかじめ定義された契約条件をプログラムとして記述し，特定の条件が満たされた際に自動的に実行する仕組みである。
中央集権的な管理者を介さず分散ネットワーク上で実行されるためプロセスの透明性や高い改ざん耐性を有している。

しかし，現在のスマートコントラクトの実装，特にEthereumに代表されるパブリックブロックチェーンにおいては，契約の実行（計算処理）とデータの記録（合意形成）が不可分な「オンチェーン実行」が主流である。
IoT技術とブロックチェーンを組み合わせるには，大きく分けて3つの課題が存在する。
第一に，計算資源の制約である。ブロックチェーンに参加する全ノードが同一の計算を重複して行う必要があるため，計算コストが極めて高い。
IoT機器上でオンチェーン実行を行うには限られたストレージや計算資源といった厳しいリソース制限から実装が難しいと考えられている\cite{bcot}。
これに対してIPFS等を用いてデータ保存をオフチェーンへ逃がすオンチェーン/オフチェーン併用モデルが提案されている\cite{offchain}。

第二に，処理性能の限界である。現在主流であるEthereumのブロックチェーン上ではスマートコントラクトを実行するEVMという仮想マシンが存在しているが，ブロックチェーンの普及が進むにつれその処理性能はより高いものが求められる。
ブロックチェーン上ですべての処理を完結させてスケールさせることには限界があり，高スループットが要求される用途ではオフチェーンで大部分の処理を行う必要性が指摘されている\cite{lightning}。
加えて，オンチェーンでの重複計算を避けるために計算をオフチェーンで実行し，オンチェーンでは結果検証のみを行う枠組みが提案されている\cite{truebit}。

第三に，経済的コストである。実行のたびに「ガス代」と呼ばれる手数料が発生し\cite{ethereum}，頻繁にデータを更新するIoTデバイスにとって大きな負担となる。

これらの課題から，現状のIoTシステムは，潤沢な計算リソースを持つクラウドサーバ上で代理実行されるケースが一般的である。
しかし，クラウド依存の構成は，通信遅延の増大や，特定のサーバがダウンした際にシステム全体が停止する単一障害点の問題を内包している\cite{bcot}。
真の意味で自律的なIoTエコシステムを構築するためには，ネットワークの末端に位置する組込み機器そのものが，スマートコントラクトの実行能力を持つことが不可欠である。
\section{研究目的}
本研究の目的は，リソース制限の厳しい組込み機器上において，スマートコントラクトを効率的に実行可能とするオフチェーン実行基盤を構築することである。
本研究では，スマートコントラクトの複雑な論理演算をブロックチェーンの外側（オフチェーン）で実行し，
その実行結果のみブロックチェーンへ接続・保存する機構を提案する。

またオフチェーンでの実行にはEVMと比較して実行速度の速いDTVMを採用することで，より処理性能を向上させる。
これにより，ブロックチェーンが持つ高いセキュリティ性を維持しつつ，オンチェーン実行のボトルネックを解消することを目指す。
本研究を通じて，組込み機器が自律的に契約を履行できる環境を示すことで，IoT社会における高度な分散型自動化システムの実現に寄与する。
\section{本論文の構成}
第2章では本研究に必要な前提知識について詳しく述べる。第3章ではオフチェーン実行とオンチェーンでの保存を組み合わせる機構について述べる。
第4章では作成した接続機構を使用して比較して評価実験を行い，組込み機器への適用性を評価する。
第5章では本研究のまとめと今後の課題について述べる。


\chapter{前提知識}
本章では，本研究に関連する専門用語について解説する。
\section{ブロックチェーン}
ブロックチェーンとは，分散型台帳技術の一種であり，複数の参加者によって取引履歴を共有・管理する仕組みである。
ブロックチェーンの特徴としてまず図\ref{fig:blockchain-data}のようなデータの保存方法が挙げられる。
取引データはブロックと呼ばれる単位にまとめられ，各ブロックは暗号学的ハッシュ関数によって直前のブロックと連結される。
この構造により，過去のデータを改ざんすることが極めて困難となり，高い耐改ざん性が実現されている。

ブロックチェーンのもう一つの特徴として，図\ref{fig:blockchain}のように中央管理者を必要としない点が挙げられる。
従来の中央集権型システムでは，単一の管理主体がデータを管理していたが，ブロックチェーンではネットワーク参加者が全員取引を実行して確認することで取引の正当性を検証する。
また中央集権型システムでは中央のサーバがエラーで止まってしまった場合，システム全体が停止してしまうが，ブロックチェーンの場合は一部のシステムが停止しても，システム全体は動き続けることができる。

このような特性から，ブロックチェーンは暗号資産だけでなく，サプライチェーン管理やIoT分野など，改ざん耐性や透明性が求められる分野への応用が進められている。
ブロックチェーンプラットフォームの代表例としてはEthereumが有名である\cite{ethereum}。
\begin{figure}[tb]
  \centering
  \includegraphics[width=0.8\textwidth]{fig/blockchain2.png}
  \caption{ブロックチェーンのデータの保存方法}
  \label{fig:blockchain-data}
\end{figure}


\begin{figure}[tb]
  \centering
  \includegraphics[width=0.8\textwidth]{fig/blockchain.png}
  \caption{ブロックチェーンの概念図}
  \label{fig:blockchain}
\end{figure}



\section{スマートコントラクト}
スマートコントラクトとは，ブロックチェーン上で実行されるプログラムのことであり，あらかじめ定義された条件が満たされた場合に，自動的に処理を実行する仕組みである。
Ethereum に代表されるブロックチェーンプラットフォームでは，スマートコントラクトがEVMという仮想マシン上で実行され，取引の自動化や信頼性の高い処理を実現している。
開発にはスマートコントラクト専用言語であるSolidityが使われている。

従来の中央集権型のようなシステム上での契約処理では，第三者機関やサーバが仲介する必要があったが，スマートコントラクトを用いることで，契約条件の検証から実行までをプログラムによって自動化できる。
これにより，契約の過程に第三者が介在することなく，人為的ミスの削減やコスト削減が可能となる。また契約が直接行われるため，契約の透明性も高くなる。

一方で，スマートコントラクトは通常，ブロックチェーン上のノードやサーバ環境で実行されるため，計算資源や実行コスト（Gas）に制約がある。
実行コスト(Gas)とはスマートコントラクトの命令ごとにあらかじめ設定された数値であり，複雑な処理ほどそのコストは高くなっている。
これによってネットワーク上で一部の処理を無限ループさせたり，複雑で重い処理を複数回実行させたりといった悪意のあるスマートコントラクトの実行を防ぎ，
ネットワーク利用者の公平性を維持している。このガスコストを計算する処理はスマートコントラクトを実行する際に自動的に追加される。
そのため組込み機器のようなリソース制約の厳しい環境で直接実行することを考えた場合，このガスコスト計算処理によってより必要なリソース量が増加し，
実行するのが困難となる可能性がある。また組込み機器が高頻度で外部のデータを取得する場合，スマートコントラクトもそれだけ高頻度で実行する必要があるため，ガスコストによって処理が実行されない場合がある。
これらの点が本研究の課題背景の一つとなっている。

\section{EVM}
\subsection{EVMとevmone}
EVM（Ethereum Virtual Machine）はEthereumに代表されるブロックチェーンプラットフォームで，スマートコントラクトを実行する仮想マシンである。
EVMはEthereum Yellow Paperにおいて仕様が定義されたスタックベースの仮想マシンであり，スマートコントラクトの実行結果をブロックチェーン上の状態として反映させる役割を担う。

EVMでは，ネットワークに参加する全ノードが同一のトランザクションを受信し，同一のスマートコントラクトを実行することで，分散合意に基づいた状態遷移を実現している。
このためEVMは，プログラム実行と状態更新，合意形成が密接に結びついた実行環境である。
一方で，全ノードによる重複実行が必要となるため，計算量の大きい処理や高頻度な実行は性能面およびガスコストの観点から制約を受ける。

evmoneは，EVM仕様に準拠した高性能なEVM実装であり，主に実行速度の向上を目的として開発されている\cite{evmone}。
C++によって実装されたevmoneは，従来広く用いられているGo言語実装のEVMと比較して，命令実行の高速化や効率的な最適化が図られている。
そのため，EVMの実行性能を改善する手段として，クライアント実装の一つとして利用されている。

\subsection{DTVM}
DTVM（Deterministic Trusted Virtual Machine）は，決定論的な実行を保証するWebAssembly（Wasm）ベースの仮想マシンであり，
主にスマートコントラクトの実行性能向上を目的として提案されている\cite{dtvm}。

DTVMの一つ目の特徴は，異なるハードウェア環境においても同一の入力に対して同一の実行結果を得られる決定論的実行を保証する点である。
図\ref{fig:dtvm}の上部よりDTVMは入力されたWasmコードをdMIRという独自の中間表現に変換しており，これによって入力されたWasmコードを決定論的なコードに変換している。
ブロックチェーンでは複数のノードが同一の計算結果を得ることを前提としてシステム全体の正当性が保たれるため，
実行環境の決定論性は不可欠な要件である。DTVMはこの要件を満たす実行環境として設計されている。

二つ目の特徴は図\ref{fig:dtvm}の下部より，dMIRからマシンコードへのコンパイル方式を二種類備えている点である。
FLAT(Function Level fAst Transpile)モードではプログラムの最適化をほとんどせず，呼び出されてからの応答性を重視している。
そして関数の呼び出された回数に応じてFLAS(Function Level Adaptive hot-Switching)モードという最適化レベルの高いコンパイル方式に切り替えることで，
コンパイル時間はFLATモードと比較して増加するが，関数全体の実行速度を向上させている。

三つ目の特徴は，DTVMはWebAssemblyを実行形式として採用しており，軽量かつ高速な実行が可能である。
DTVM論文では，EVMと比較してスマートコントラクトの実行時間が大幅に短縮されることがベンチマークにより示されている\cite{dtvm}。
さらに，C++やRustなどの言語で記述されたプログラムに加えて，Solidityで記述されたスマートコントラクトもWasmへ変換して実行可能とする互換性を備えており，
既存のEVM向けスマートコントラクト資産を活用できる点もDTVMの研究成果として示されている。その際のガスコスト計算についてはEVMの模倣または簡易モデルを使用している。

一方で，DTVMは実行結果の正当性検証や悪意ある実行に対する検出機構を提供しない。
また，実行結果をブロックチェーン上に保存する機能や，ネットワークを介した合意形成機構も備えていない。
これらの機能はDTVM論文においても実行基盤の範囲外として明確に分離されており，
DTVMは現状あくまで決定論的かつ高速なプログラム実行マシンとして設計されている。


\begin{figure}[tb]
  \centering
  \includegraphics[width=0.8\textwidth]{fig/dtvm.png}
  \caption{DTVMのコンパイル方式図}
  \label{fig:dtvm}
\end{figure}

\FloatBarrier


\subsection{仮想マシンの比較}

表\ref{tab:vm-compare}にEVM，evmone，DTVMの比較表を示す。
EVMおよびevmoneはスマートコントラクト実行と
ブロックチェーン上の状態更新・合意形成を一体として扱う実行環境である。
一方でDTVMは，合意形成や状態管理機構を持たず，
決定論的かつ高速なプログラム実行のみを担う実行基盤である。
またDTVM論文ではevmoneとの性能比較が行われており，DTVMが実行時間の観点で優れた結果を示している\cite{dtvm}。


以上のことから本研究ではオフチェーン実行向きであり，かつ実行速度も速く，Solidityのコントラクトを実行可能という点からDTVMをオフチェーン実行基盤として採用しする。
これにより，EVMによるフルオンチェーン実行では困難であった
リソース制約環境におけるスマートコントラクト実行を実現することを目指す。

なお一般にWasmベースの仮想マシンはブラウザ環境に組み込まれ，クライアント側での安全かつ高速なコード実行に利用されることが多い。
しかし本研究ではブラウザ用途ではなく，仮想マシンを独立したオフチェーン実行基盤として利用する。

\begin{table}[tb]
  \centering
  \caption{EVM，evmone，DTVMにおける提供機能の比較}
  \label{tab:vm-compare}
  \begin{tabular}{p{3.2cm}p{3.7cm}p{3.7cm}p{3.7cm}}
    \toprule
    項目 & EVM & evmone & DTVM\\
    \midrule

    主な目的 &
    ブロックチェーン上でのSC実行と状態更新 &
    EVM命令の高速実行 &
    決定論的・高速なプログラム実行 \\

    実行場所 &
    ブロックチェーン上 (オンチェーン)  &
    ブロックチェーン上 (オンチェーン)  &
    ブロックチェーン外 (オフチェーン) \\

    合意形成との関係 &
    合意形成・状態遷移と一体 &
    合意形成・状態遷移と一体 &
    合意形成を提供しない \\

    実行結果の扱い &
    実行結果がそのまま状態として保存 &
    実行結果がそのまま状態として保存 &
    実行結果の保存は外部に委ねる \\

    決定論性 &
    保証される &
    保証される &
    保証される \\

    実行形式 &
    EVMバイトコード &
    EVMバイトコード &
    WebAssembly（Wasm） \\

    実行性能 &
    比較的低速 &
    高速(EVM比) &
    高速(evmone比) \\

    ガスコスト計算 &
    あり &
    あり &
    あり（EVMの模倣または簡易モデル） \\

    セキュリティ（検証） &
    ネットワーク全体で検証（合意に組込まれる） &
    ネットワーク全体で検証（合意に組込まれる） &
    実行結果の正当性検証は未提供 \\

    \bottomrule
  \end{tabular}
\end{table}

\FloatBarrier



\chapter{提案手法}
本章では，本研究で提案する手法について述べる。
\section{提案アーキテクチャ}
本研究では，スマートコントラクトの計算処理をすべてブロックチェーン上で実行する従来のフルオンチェーン実行方式に代わり，
オフチェーン実行とオンチェーン同期を組み合わせたアーキテクチャを提案する。

従来の方式では，トランザクションが発行されるたびに，ブロックチェーンに参加する全ノード上でスマートコントラクトが実行され，計算結果が状態として保存される。
この方式は高い改ざん耐性を持つ一方で，計算資源の浪費やガスコストの増大といった問題を抱えている。

これに対し，本研究で提案するアーキテクチャでは，スマートコントラクトの計算処理をブロックチェーン外のオフチェーン環境で実行し，
実行された計算結果は，ブロックチェーン上の保存用スマートコントラクトを介して状態として記録される。

またそのオフチェーン実行基盤として，本研究ではDTVMを採用する。DTVMは決定論的な実行を保証するWasmベースの仮想マシンであり，
異なる実行環境においても同一の入力に対して同一の実行結果を得られる。この決定論性は，ブロックチェーンと連携する実行環境として重要な要件である。
しかしDTVMは現状高速なプログラム実行マシンであり，ブロックチェーンへ接続する機能や状態保存，合意形成といった機能は未提供である。

表\ref{tab:arch-role}に示す通り，本研究ではオフチェーンで実行した結果をブロックチェーンへと送信する部分を対象とした接続機構を提案する。
そのためオフチェーン実行部の合意形成を行わないため，セキュリティ面での課題が残る。またオフチェーン実行の際に状態保存等を行わないため，
以前実行した結果を再利用することもできない。これらについては第5章にて今後の課題として述べる。

\begin{table}[tb]
  \centering
  \caption{提案アーキテクチャにおける機能分担}
  \label{tab:arch-role}
  \begin{tabular}{p{4cm}p{4cm}p{4cm}}
    \toprule
    機能 & DTVM & 本研究で実装 \\
    \midrule
    計算処理の実行 & 提供 & 利用 \\
    決定論的実行 & 提供 & 利用 \\
    Wasm / Solidity実行 & 提供 & 利用 \\
    ブロックチェーンへの送信 & 未提供 & 実装 \\
    状態保存 & 未提供 &  今後の課題 \\
    合意形成 & 未提供 & 今後の課題 \\
    \bottomrule
  \end{tabular}
\end{table}


また図\ref{fig:chain}に，従来のフルオンチェーンの方式と提案アーキテクチャでの処理の流れを示す。
本研究での提案手法ではブロックチェーン上で実行される処理が削減出来ていることが分かる。
ブロックチェーン上で実行される処理量を削減することで，ガスコストの低減および実行負荷の軽減を図る。

\begin{figure}[tb]
  \centering
  \begin{subfigure}[t]{0.48\textwidth}
    \centering
    \includegraphics[height=8cm]{fig/fullchain.png}
    \caption{フルオンチェーン}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.48\textwidth}
    \centering
    \includegraphics[height=8cm]{fig/offchain.png}
    \caption{オフチェーン実行＋オンチェーン同期}
  \end{subfigure}
  \caption{実行方式の比較}
  \label{fig:chain}
\end{figure}
\FloatBarrier

\section{接続機構の設計}
本研究で提案するアーキテクチャを実現するためには，オフチェーン実行基盤であるDTVMと，ブロックチェーン上のスマートコントラクトを接続する機構が必要となる。

DTVMは決定論的なプログラム実行を提供する一方で，実行結果をブロックチェーンに保存する機能や，ネットワークを介した合意形成機構を備えていない。
そのため，DTVMの実行結果を取得し，ブロックチェーンへ送信する中間的な接続機構を設計する必要がある。

本研究ではこの接続機構として，JavaScriptで記述された制御プログラムを用いる。
このプログラムは以下の役割を担う。

\begin{itemize}
  \item DTVMの実行バイナリを呼び出し，Wasmプログラムを実行する
  \item DTVMの標準出力から実行結果を取得する
  \item 取得した実行結果をブロックチェーン上の保存用スマートコントラクトへ送信する
\end{itemize}

ブロックチェーンとの接続には，Ethereum向け開発環境であるHardhatを使用する。
Hardhatを用いることで，ローカルブロックチェーン環境上でスマートコントラクトを実行し，
実行結果やガスコストを取得することが可能となる。

\section{実装}
本節では，提案手法に基づいて実装したプロトタイプについて述べる。

実装にはNode.jsを用い，Hardhatを通じてブロックチェーンと接続する。
オフチェーン実行部では，DTVMの実行バイナリに対してWasmファイルと引数を渡し，スマートコントラクト相当の処理を実行する。

図\ref{fig:dtvm-script}に示す実験スクリプトでは，runDTVM関数内でDTVMを呼び出し，Wasmプログラムの実行結果を取得している。
その後，取得した実行結果をあらかじめデプロイしておいた保存用スマートコントラクトに送信し，ブロックチェーン上の状態として保存する。

従来のフルオンチェーン実行方式では，スマートコントラクトの計算処理から状態更新までが一度のトランザクションで完結する。
一方で本実装では，オフチェーン実行とオンチェーン保存が分離されており，DTVMの呼び出しとトランザクション送信という二段階の処理が必要となる。

この構成によりガスコストの削減が期待される一方，接続機構によるオーバーヘッドが発生する可能性がある。
本研究ではこの点に着目し，次章において実行時間，メモリ使用量，およびガスコストの観点から評価を行う。

\begin{figure}[tb]
  \centering
  \begin{minipage}{0.95\textwidth}
  \begin{lstlisting}
  console.log("cwd =", process.cwd());
  
  const { ethers } = require("hardhat");
  const { execSync } = require("child_process");
  
  // Hardhat ローカルノードにデプロイ済みのコントラクト
  const CONTRACT_ADDRESS = "0x5FbDB2315678afecb367f032d93F642f64180aa3";
  
  //DTVMに実行するWasmファイルを渡して実行させ，結果を取得する関数
  async function runDTVM(n) {
    const cmd = `../dtvm ./fibo.wasm -f run --args ${n}`;
    const output = execSync(cmd).toString().trim();
  
    console.log("DTVM output:"， output);
  
    if (output.includes(":")) {
      return Number(output.split(":")[0]);
    }
    return Number(output);
  }
  
  async function main() {
    const Store = await ethers.getContractFactory("ResultStorage");
    const store = await Store.attach(CONTRACT_ADDRESS);
  
    //DTVM呼び出し
    const r = await runDTVM(5);
  
    //保存用コントラクトを呼び出して，結果をブロックチェーン上に保存
    const tx = await store.storeResult(r);
    const receipt = await tx.wait();     
  }
  
  main().catch(console.error);
  \end{lstlisting}
  \end{minipage}
  \caption{DTVMを呼び出して結果をオンチェーン保存する実験スクリプト}
  \label{fig:dtvm-script}
\end{figure}


\chapter{評価実験}
本章では，本研究で実施した評価実験の内容，実験環境，そしてその結果と考察について述べる。
\section{実験概要}
本実験ではフィボナッチ数列を計算するプログラムを対象として，2つのパターンでその実行時間，メモリ使用量，そして必要なガスコストを計測した。
実行は組込み機器上ではなくPC上で行い，実行結果をもとに組込み機器への適用性を評価した。
実行するパターンは以下の2つである。
\subsection{パターン１:EVMによるフルオンチェーンでの実行}
従来のフルオンチェーン型の例として，Solidityで書いたフィボナッチ数列のスマートコントラクトをブロックチェーン上で実行する。
\subsection{パターン２:DTVMによるオフチェーン実行(実行するWasmファイルの元の言語はC++)}
DTVMを用いた提案手法の仕組みを使い，C++で書いたプログラムをWasmバイトコードにコンパイルして実行する。


\section{実験環境}
本研究で使用した実験環境を，
ハードウェア環境とソフトウェア環境に分けて
表\ref{tab:hw-env}および表\ref{tab:sw-env}に示す。

\begin{table}[tb]
  \centering
  \caption{実験環境（ハードウェア）}
  \label{tab:hw-env}
  \begin{tabular}{ll}
    \toprule
    項目 & 内容 \\
    \midrule
    実行環境 & PC（WSL2上で実行） \\
    OS & Windows 11 Home \\
    プロセッサ & Intel Core Ultra 5 125U \\
    メモリ & 16 GB \\
    アーキテクチャ & x86\_64 \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}[tb]
  \centering
  \caption{実験環境（ソフトウェア）}
  \label{tab:sw-env}
  \begin{tabular}{ll}
    \toprule
    ソフトウェア & バージョン \\
    \midrule
    Ubuntu (WSL2) & 24.04.3 LTS \\
    Linux Kernel & 6.6.87.2-microsoft-standard-WSL2 \\
    DTVM & v1.0.0 \\
    Hardhat & v2.28.3 \\
    Node.js & v22.22.0 \\
    npm & v10.9.4 \\
    \bottomrule
  \end{tabular}
\end{table}

\section{実験内容}
フィボナッチ数列30から40を順番に計算するプログラムを対象にプログラム全体の実行時間，それぞれのプログラムの異なる部分である仮想マシンの呼び出し部分のみの実行時間，最大メモリ使用量，また数列40を計算して保存する際のガスコストを計測した。
実行するフィボナッチ数列のプログラムはパターン１はSolidityで作成した図\ref{fig:fibo-sol}，パターン２はc++で作成した図\ref{fig:fibo-c++}をWasmにコンパイルしたものを使用した。
またフィボナッチ数列の引数を30から40に変化させて呼び出すためのプログラムはどちらのパターンもjavascriptで作成して図\ref{fig:program1}，\ref{fig:program2}のようになった。
プログラム全体の実行時間はこの二つのプログラムの全体の実行時間のことで，仮想マシンの呼び出し部分のみの実行時間というのはmain内のforループで囲まれている範囲のみの実行時間のことである。
\subsection{測定方法}

本実験では，実行時間，メモリ使用量，およびガスコストの3項目を測定した。各測定方法を以下に示す。
なおそれぞれの項目において，各パターンを30回ずつ実行した結果の平均値を実験結果とした。
\subsubsection{実行時間の測定方法}

実行時間は2種類測定した。

(1) プログラム全体の実行時間  
Linuxの\texttt{/usr/bin/time -v}コマンドを用いて計測した。
具体的には，以下のように各実行スクリプトを測定した。

\begin{verbatim}
/usr/bin/time -v npx hardhat run script.js
\end{verbatim}

このとき出力される ``Elapsed (wall clock) time'' を
プログラム全体の実行時間として採用した。

(2) 仮想マシン呼び出し部分の実行時間  
Node.jsが提供する \texttt{performance.now()} を用いて，
forループ開始直前および終了直後の時刻差を計測した。
測定対象は図\ref{fig:program1}および図\ref{fig:program2}に示すfor文内の処理全体である。

各パターンについて30回実行し，その平均値を比較に用いた。

\subsubsection{メモリ使用量の測定方法}

メモリ使用量は \texttt{/usr/bin/time -v} の出力に含まれる``Maximum resident set size'' を最大メモリ使用量として採用した。

\subsubsection{ガスコストの測定方法}

ガスコストは，各トランザクション実行後に取得されるトランザクションレシートの \texttt{gasUsed} を使用した。
測定対象はフィボナッチ数列40を計算し，ブロックチェーン上へ保存する処理である。
実行はHardhatのローカルネットワーク上で実行した。
Hardhatのローカルネットワーク上で実行し，30回実行した際の平均値を比較対象とした。

\begin{figure}[tb]
  \centering
  \begin{minipage}{0.95\textwidth}
  \begin{lstlisting}
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.20;
  
  contract FibonacciStorage {
  uint256 public lastResult;
  uint256 public lastInput;
  
    function fibonacci(uint256 n) public pure returns (uint256) {
        if (n == 0) return 0;
        if (n == 1) return 1;
    
        uint256 a = 0;
        uint256 b = 1;
    
        for (uint256 i = 2; i <= n; i++) {
            uint256 c = a + b;
            a = b;
            b = c;
        }
    
        return b;
    }
    
    function computeAndStore(uint256 n) external {
        uint256 result = fibonacci(n);
        lastInput = n;
        lastResult = result;
    }
  }
  \end{lstlisting}
  \end{minipage}
  \caption{パターン１用フィボナッチ数列(Solidity)}
  \label{fig:fibo-sol}
\end{figure}

\begin{figure}[tb]
  \centering
  \begin{minipage}{0.95\textwidth}
  \begin{lstlisting}
  extern "C" unsigned long long run(unsigned long long n) {
      if (n == 0) return 0;
      if (n == 1) return 1;
  
      unsigned long long prev = 0;
      unsigned long long curr = 1;
  
      for (unsigned long long i = 2; i <= n; ++i) {
          unsigned long long next = prev + curr;
          prev = curr;
          curr = next;
      }
  
      return curr;
  }
  \end{lstlisting}
  \end{minipage}
  \caption{パターン２用フィボナッチ数列}
  \label{fig:fibo-c++}
\end{figure}

\begin{figure}[tb]
  \centering
  \begin{minipage}{0.95\textwidth}
  \begin{lstlisting}
  import pkg from "hardhat";
  import { performance } from "node:perf_hooks";
  
  const { ethers } = pkg;
  
  // Hardhat ローカルノードにデプロイ済みのコントラクト
  const CONTRACT_ADDR = "0x5FbDB2315678afecb367f032d93F642f64180aa3";
  
  async function main() {
    const Fib = await ethers.getContractFactory("FibonacciStorage");
    const fib = await Fib.attach(CONTRACT_ADDR);
    const start = performance.now();
  
    for (let n = 30; n <= 40; n++) {
      const tx = await fib.computeAndStore(n);
      const receipt = await tx.wait();
  
      const result = await fib.lastResult();
    
      console.log("n ="， n);
      console.log("result ="， result.toString());
      console.log("gasUsed ="， receipt.gasUsed.toString());
  
    }
    const end = performance.now();
    console.log("wallTime(ms) ="， (end - start).toFixed(2));
  }
  
  main().catch(console.error);
  
  \end{lstlisting}
  \end{minipage}
  \caption{パターン１用実行プログラム}
  \label{fig:program1}
\end{figure}

\begin{figure}[tb]
  \centering
  \begin{minipage}{0.95\textwidth}
  \begin{lstlisting}
  console.log("cwd =", process.cwd());
  
  const { ethers } = require("hardhat");
  const { execSync } = require("child_process");
  
  
  // Hardhat ローカルノードにデプロイ済みのコントラクト
  const CONTRACT_ADDRESS = "0x5FbDB2315678afecb367f032d93F642f64180aa3";
  
  async function runDTVM(n) {
    const cmd = `../dtvm ./fibo.wasm -f run --args ${n}`;
    const output = execSync(cmd).toString().trim();
  
    console.log("DTVM output:", output);
  
    if (output.includes(":")) {
      return Number(output.split(":")[0]);
    }
    return Number(output);
  }
  
  
  async function main() {
    const Store = await ethers.getContractFactory("ResultStorage");
    const store = await Store.attach(CONTRACT_ADDRESS);
    const start = performance.now();
  
    for (let n = 30; n <= 40; n++) {
      const r = await runDTVM(n);
      const tx = await store.storeResult(r);
      const receipt = await tx.wait();     
      const result = await store.lastResult();
    
      console.log("n =", n);
      console.log("result =", result.toString());
      console.log("gasUsed =", receipt.gasUsed.toString());
    }
    const end = performance.now();
    console.log("wallTime(ms) =", (end - start).toFixed(2));
  }
  
  main().catch(console.error);
  \end{lstlisting}
  \end{minipage}
  \caption{パターン２用実行プログラム}
  \label{fig:program2}
\end{figure}

\FloatBarrier


\section{実験結果}
結果は図\ref{fig:time}，\ref{fig:calltime}，\ref{fig:memory}，\ref{fig:gas}のようになった。
プログラム全体の実行時間は，パターン1が平均1.179秒であったのに対し，パターン2は平均1.245秒となり，
約5.6\%の増加が確認された。
仮想マシン呼び出し部分の実行時間は，パターン1と比較してパターン2が約0.1秒増加しており，
この差はプログラム全体の実行時間の差と一致している。
最大メモリ使用量は，パターン1が約131,577 KB，パターン2が約133,209 KBとなり，
約1.2\%の増加が確認された。
一方，ガスコストについては，パターン1が47,050 gasであったのに対し，パターン2は26,638 gasとなり，
約43.4\%の削減が確認された。
\begin{figure}[tb]
  \centering
  \includegraphics[width=0.8\textwidth]{fig/time.png}
  \caption{プログラム全体の実行時間の比較}
  \label{fig:time}
\end{figure}
\begin{figure}[tb]
  \centering
  \includegraphics[width=0.8\textwidth]{fig/calltime.png}
  \caption{仮想マシン呼び出し部分の実行時間の比較}
  \label{fig:calltime}
\end{figure}

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.8\textwidth]{fig/memory.png}
  \caption{メモリ使用量の比較}
  \label{fig:memory}
\end{figure}
\begin{figure}[tb]
  \centering
  \includegraphics[width=0.8\textwidth]{fig/gas.png}
  \caption{ガスコストの比較}
  \label{fig:gas}
\end{figure}

\FloatBarrier

\section{考察}
結果よりパターン１と比較してパターン２は実行時間が約5.6\%,メモリ使用量が約1.2\%増加した。
これは呼び出し部分の実行時間の比較から，パターン１はオンチェーン上のコントラクトを一度呼び出すとフィボナッチの計算からチェーン上に保存するまでをまとめて実行するのに対して，
パターン２ではローカルにあるDTVMを呼び出した後にオンチェーン上の保存用コントラクトを呼び出すという二回の手順を行っているオーバーヘッドが大きいためであると考えられる。

この問題を解決するにはDTVMのローカル実行呼び出しとブロックチェーンへの接続を担う間の機構を一括で実行できるようなシンプルで単純なものにする必要がある。
例えば本実験では図\ref{fig:chain}(b)のようにDTVMからの実行結果を一度プログラムに渡して，プログラムがブロックチェーンにその結果を送信したが，
DTVMが実行するWasmファイルにブロックチェーンに結果を送信する部分までを含ませることができれば，DTVMから直接ブロックチェーンに結果を保存することが可能になり，本実験で2回の手順で行っていた部分が
一回で済み，オーバーヘッドが減少すると考えられる。

本研究ではオフチェーン実行＋オンチェーン同期型を組込み機器上でも実行できるようにすることが目的である。
実験結果より本実験の環境下において今回作成した接続機構はRaspberry Pi 4(2GB)程度のリソース量があれば十分実行可能であることが確認できた。しかし今回使用したフィボナッチ数列のプログラムは比較的単純であり，
より本格的な複雑な処理を行うプログラムの場合はどれほどオーバーヘッドが大きくなるのか検証する必要がある。その大きさの度合いによっては組込み機器への適用は難しい可能性がある。
そのため実行時間，メモリ使用量の2つを改善するためにも新たなDTVMとブロックチェーンの接続機構を作成する必要がある。

ただガスコストについてはパターン２の方が40\%以上削減できることが分かった。そのためオフチェーン実行を実現することができれば
今までブロックチェーン上ではできなかった複雑な処理を実行することができたり，高頻度でプログラムを実行できたりするといったメリットが出てくると考えられる。




\chapter{おわりに}
\section{まとめ}
本研究ではWasmベースで開発言語の多い仮想マシンであるDTVMを使用して，従来のフルオンチェーンによるスマートコントラクト実行に代わる，オフチェーンでのDTVM実行+結果のみブロックチェーンに保存する
仕組みを作成した。そして組込み機器への適用性を評価するために実行時間，メモリ使用量，そしてガスコストを計測して比較した。
実験結果では，従来のフルオンチェーン型の方式と比較して本研究で提案した手法の方が実行時間が約5.6\%,メモリ使用量が約1.2\%増加した。
これは本研究で作成した接続機構が,計算処理の実行と結果の保存を2回に分けて実行していることによるオーバーヘッドが大きいためであると考えられる。
この結果から本研究で作成した機構はRaspberry Pi 4程度のリソース量があれば十分実行可能であるが，より複雑な処理を行うプログラムの場合にオーバーヘッドがどれほど増加するか
再検証する必要があることを確認した。またオーバーヘッドの増加量が大きい場合に備えて，作成方法を変えて新たな接続機構を作る必要があることを確認した。またそれと同時にガスコストについては
オフチェーン実行の方が40\%以上削減できており，ガスコスト削減の観点でのオフチェーン実行+オンチェーン同期型の有用性を確認した。
\section{今後の課題}
本論文の実験では簡単なプログラムを対象にシンプルな比較実験を行ったが，IoT機器でのブロックチェーン動作を検証するためにも
今後はより具体的なユースケース(例:IoT機器でのデータのやり取りを目的としたブロックチェーンシステム\cite{marketplace})に対しても検証する必要がある。
そして本実験ではPC上で比較実験，評価を行ったが，実際にRaspberry PiやIoT機器等で同様の実験を行い，本実験での結果との差異がどの程度あるのかも検証する必要がある。
リソース量によって実行性能の低下やネットワーク接続が不安定になる可能性がある。

またオフチェーン実行によるデメリットであるセキュリティ性の低下と，状態保存がされないことから結果を再利用することができないという二つの点も解決する必要がある。
セキュリティ面について本研究の方式では，オフチェーン実行部分の改ざん検知が課題となる。従来のフルオンチェーンの場合，
全ノードでコントラクトを検証し，実行の正当性を確認することができる。しかし本研究の方式では実行部分であるオフチェーンを改ざんされた場合に，直接実行部分を確認しない限り
発見することができない。これに対し，実行環境を信頼実行環境（TEE）で保護し，合意層と実行層を分離するアーキテクチャ\cite{ekiden}や，
あるいはzk-SNARK等によるオフチェーン計算の証明生成とオンチェーン検証\cite{zksnark}といったアプローチが考えられる。

状態保存については，DTVMはあくまでも軽量かつ高速なプログラム実行環境であり，ブロックチェーン的な動作は未提供である。そのため前回の実行結果を利用する場合はその結果をローカルで保存しておく必要がある。
フルオンチェーンの場合は前回の結果をチェーン上に状態として保存しておき，再利用が可能だが，DTVMはローカル実行でありかつ状態保存機能は未提供のため，前回の結果をローカルに保持しておき，再利用できるような
仕組みを考案，作成する必要がある。


% ===== 参考文献 =====
\begin{thebibliography}{9}

\bibitem{iot-blockchain}
K. Christidis and M. Devetsikiotis，  
\textit{Blockchains and Smart Contracts for the Internet of Things}，  
IEEE Access， vol. 4， pp. 2292--2303， 2016.  
\url{https://ieeexplore.ieee.org/document/7467408}

\bibitem{security}
Ali Dorri， et al.
\textit{Blockchain for IoT Security and Privacy: The Case
Study of a Smart Home}，  
Conference	Paper	·	March	2017 
\url{https://people.cs.pitt.edu/~mosse/courses/cs3720/Blockchain_for_IoT_Security_and_Privacy.pdf}

\bibitem{bcot}
H.-N. Dai， Z. Zheng， and Y. Zhang，
\textit{Blockchain for Internet of Things: A Survey}，
\url{https://arxiv.org/pdf/1906.00245}


\bibitem{offchain}
Pooja Khobragade  
\textit{On-chain Off-chain Blockchain Model for IoT
using IPFS}，  
IET Conference Proceedings， July 2023
\url{https://www.researchgate.net/publication/373003375_On-chain_off-chain_blockchain_model_for_IoT_using_IPFS}

\bibitem{lightning}
J. Poon and T. Dryja，  
\textit{The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments}，  
2016.  
\url{https://lightning.network/lightning-network-paper.pdf}


\bibitem{truebit}
J. Teutsch and C. Reitwie{\ss}ner，
\textit{A Scalable Verification Solution for Blockchains}，
\url{https://arxiv.org/pdf/1908.04756}


\bibitem{ethereum}
G. Wood，  
\textit{Ethereum: A Secure Decentralised Generalised Transaction Ledger}，  
Ethereum Yellow Paper， 2014.  
\url{https://ethereum.github.io/yellowpaper/paper.pdf}

\bibitem{evmone}
Ipsilon
\textit{evmone : Fast Ethereum Virtual Machine implementation}，  
\url{https://github.com/ipsilon/evmone}


\bibitem{dtvm}
Wei Zhou， et al.  
\textit{DTVM: REVOLUTIONIZING SMART CONTRACT EXECUTION
WITH DETERMINISM AND COMPATIBILITY}，  
June 10， 2025
\url{https://arxiv.org/pdf/2504.16552v2}





\bibitem{marketplace}
Kenta Kawai， Wu Yuxiao， Yutaka Matubara， and Hiroaki Takada
\textit{BLOCKCHAIN-BASED DEMAND-SUPPLY 
MATCHING SYSTEM FOR IOT DEVICE DATA 
DISTRIBUTION }，  
2024
\url{https://aircconline.com/csit/papers/vol14/csit142408.pdf}



\bibitem{ekiden}
R. Cheng， et al.，
\textit{Ekiden: A Platform for Confidentiality-Preserving， Trustworthy， and Performant Smart Contract Execution}，
\url{https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8806762}

\bibitem{zksnark}
Alvaro Alonso Domenech， Jonathan Heiss， Stefan Tai
\textit{Servicifying zk-SNARKs Execution for
Verifiable Off-chain Computations}，
\url{https://arxiv.org/pdf/2404.16915}



\end{thebibliography}

\end{document}
